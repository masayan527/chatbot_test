@角丸め
--track0:半径,0,333,0
--track1:ぼかし,0,100,0
local radius = obj.track0
local blur = obj.track1 / 100

require("ymm4native")
local ox = obj.ox
local oy = obj.oy
local oz = obj.oz
local rx = obj.rx
local ry = obj.ry
local rz = obj.rz
local cx = obj.cx
local cy = obj.cy
local cz = obj.cz

obj.effect()
local dst = obj.getpixeldata("work")
local src, dst_w, dst_h = obj.getpixeldata()
ymm4native.copy(dst, src, dst_w, dst_h)

obj.effect("ぼかし", "範囲", radius)
local src_w,src_h
src, src_w, src_h = obj.getpixeldata()

ymm4native.linear_transfer(src, src_w, src_h, 3, -255, 2)
ymm4native.linear_transfer(src, src_w, src_h, 3, 0, 255 / (254*blur+1))
ymm4native.alpha_mask(dst, dst_w, dst_h, src, src_w, src_h);

obj.setoption("drawtarget","tempbuffer",dst_w,dst_h)
obj.load("tempbuffer")
obj.putpixeldata(dst)

obj.ox=ox
obj.oy=oy
obj.oz=oz
obj.rx=rx
obj.ry=ry
obj.rz=rz
obj.cx=cx
obj.cy=cy
obj.cz=cz

@ノイズ（設定）
--track0:強さ,0,200,100,0.1
--track1:しきい値,0,100,0,0.1
--track2:速度X,-800,800,0,0.1
--track3:速度Y,-800,800,0,0.1
NoiseStrength = obj.track0
NoiseThreshold= obj.track1
NoiseSpeedX   = obj.track2*-1
NoiseSpeedY   = obj.track3*-1

@ノイズ（描画）
--track0:変化速度,0,800,0,0.1
--track1:サイズX,0,4000,100,0.1
--track2:サイズY,0,4000,100,0.1
--track3:タイプ,0,5,0,1
--dialog:シード値,local seed=0;
local noiseSpeedZ = obj.track0
local noiseScaleX = obj.track1/100
local noiseScaleY = obj.track2/100
local noiseType   = obj.track3
local noiseSeed   = seed
if noiseScaleX == 0 then
	noiseScaleX = 4000
else
	noiseScaleX = 1 / noiseScaleX
end
if noiseScaleY == 0 then
	noiseScaleY = 4000
else
	noiseScaleY = 1 / noiseScaleY
end

obj.effect("ノイズ", "強さ", NoiseStrength, "速度X", NoiseSpeedX, "速度Y",NoiseSpeedY, "変化速度", noiseSpeedZ, "周期X", noiseScaleX, "周期Y", noiseScaleY, "しきい値", NoiseThreshold, "type", noiseType, "mode", 0, "seed", noiseSeed)

@集中線（設定）
--track0:サイズ,0,8000,2000,0.1
--track1:密度,0,100,55,0.1
--track2:太さ,0,100,0,0.1
--track3:長さ,0,100,85,0.1
--color:0xffffff
CSize = obj.track0
CDensity = obj.track1
CThickness = obj.track2
CLength = obj.track3
CColor = color

@集中線（描画）
--track0:中心幅,0,100,10,0.1
--track1:速さ,0,100,25,0.1
local ccenter = obj.track0
local cspeed = obj.track1

local rectSize = math.max(2, CSize * math.pi / 4)
local xscale = 20 * (1 - CThickness / 100.0)
local yscale = 0.5 * (1 - CLength / 100.0)
local cwidth = rectSize * ccenter / 100.0

obj.load("figure", "四角形", CColor, rectSize)
obj.effect("ノイズ", "速度Y", -cspeed, "周期X", xscale, "周期Y", yscale, "しきい値",100- CDensity)

obj.effect("クリッピング", "上", cwidth)
obj.effect("ぼかし", "範囲", cwidth, "縦横比", -100)
obj.effect("極座標変換", "中心幅", cwidth / 2)

@タイマー
--track0:初期値,-8000,8000,0,0.01
--track1:速度,0,8000,100,0.1
--track2:サイズ,0,1000,34,1
--dialog:文字色/col,local color1=0xffffff;装飾色/col,local color2=0xff0000;フォーマット,local format=0;装飾,local style=0;フォント,local font="メイリオ";モード,local direction=0;

local initialValue = obj.track0
local playbackRate = obj.track1
local fontSize = obj.track2
if direction == 1 then
	initialValue = initialValue + obj.totaltime
	playbackRate = playbackRate * -1
end

local value = initialValue + obj.time * playbackRate / 100
local text = ""
if format == 0 then
	text = string.format("%01d",value)
elseif format == 1 then
	text = string.format("%02d",value)
elseif format == 2 then
	text = string.format("%03d",value)
elseif format == 3 then
	text = string.format("%04d",value)
elseif format == 4 then
	local sec = value%60
	local mil = value%1*100
	text = string.format("%02d.%02d", sec, mil)
elseif format == 5 then
	local min = value/60%60
	local sec = value%60
	text = string.format("%02d:%02d", min, sec)
elseif format == 6 then
	local min = value/60%60
	local sec = value%60
	local mil = value%1*100
	text = string.format("%02d:%02d.%02d", min, sec, mil)
elseif format == 7 then
	local hrs = value/3600%24
	local min = value/60%60
	local sec = value%60
	text = string.format("%02d:%02d:%02d", hrs, min, sec)
elseif format == 8 then
	local hrs = value/3600%24
	local min = value/60%60
	local sec = value%60
	local mil = value%1*100
	text = string.format("%02d:%02d:%02d.%02d", hrs, min, sec, mil)
end

obj.setfont(font, fontSize, style, color1, color2)
obj.load("text", text)

@砕け散りながら登場退場
--track0:効果時間,0,8000,0,0.01
--track1:X,-8000,8000,0,0.1
--track2:Y,-8000,8000,0,0.1
--track3:Z,-8000,8000,0,0.1
--dialog:登場時/chk,local is_in=1;退場時/chk,local is_out=1;破片サイズ,local size=50;飛散速度,local speed=100;落下速度,local grav=100;時間差,local delay=100;距離影響,local impact=100;ランダム回転,local spin=100;ランダム方向,local diff=100;再生速度,local step=1.0;

local effect_time = obj.track0
local in_time = 0
local out_time = 0
if is_in == 1 and obj.time < effect_time then
	in_time = effect_time - obj.time
end
if is_out == 1 and obj.totaltime - obj.time < effect_time then
	out_time = effect_time - (obj.totaltime - obj.time)
end
local tm = math.max(in_time, out_time) * step

-- 以下、exedit.anm より
local px={}
local py={}
local pz={}
local pu={}
local pv={}

if( tm < 0 ) then
	return
end
obj.effect()
grav = grav*6
delay = delay*0.002
impact = impact*0.1
spin = math.floor(spin*10)
diff = diff/80
if( size < 10 ) then
	size = 10
end 
xl = obj.w
yl = obj.h
ax = obj.track1
ay = obj.track2
az = obj.track3
sp = speed*0.01*math.sqrt(impact)
w = math.floor(xl/size)
h = math.floor(yl/size)
l = math.sqrt(xl*xl+yl*yl)
if( w < 2 ) then
	w = 2
elseif( w > xl ) then
	w = xl
end
if( h < 2 ) then
	h = 2
elseif( h > yl ) then
	h = yl
end
pw = xl/w/2.3
ph = yl/h/2.3
for y=0,h-1 do
	for x=0,w-1 do
		-- 各頂点を計算
		pu[0] = xl*x/w
		pu[1] = xl*(x+1)/w
		pu[2] = pu[1]
		pu[3] = pu[0]
		pv[0] = yl*y/h
		pv[1] = pv[0]
		pv[2] = yl*(y+1)/h
		pv[3] = pv[2]
		pu[0] = pu[0] + obj.rand(-pw,pw,x  ,y  )
		pu[1] = pu[1] + obj.rand(-pw,pw,x+1,y  )
		pu[2] = pu[2] + obj.rand(-pw,pw,x+1,y+1)
		pu[3] = pu[3] + obj.rand(-pw,pw,x  ,y+1)
		pv[0] = pv[0] + obj.rand(-ph,ph,x  ,y  +1000)
		pv[1] = pv[1] + obj.rand(-ph,ph,x+1,y  +1000)
		pv[2] = pv[2] + obj.rand(-ph,ph,x+1,y+1+1000)
		pv[3] = pv[3] + obj.rand(-ph,ph,x  ,y+1+1000)
		if( x == 0 ) then
			pu[0] = 0
			pu[3] = 0
		elseif ( x == w-1 ) then
			pu[1] = xl
			pu[2] = xl
		end
		if( y == 0 ) then
			pv[0] = 0
			pv[1] = 0
		elseif ( y == h-1 ) then
			pv[2] = yl
			pv[3] = yl
		end
		-- 基準の計算
		gx = (pu[0]+pu[1]+pu[2]+pu[3])/4
		gy = (pv[0]+pv[1]+pv[2]+pv[3])/4
		gz = 0
		cx = gx-xl/2
		cy = gy-yl/2
		cz = 0
		vx = cx-ax
		vy = cy-ay
		vz = -az
		v = math.sqrt(vx*vx+vy*vy+vz*vz)
		-- 時間の計算
		t = tm-v/l*delay
		if( t < 0 ) then
			t = 0
			obj.setoption('antialias',0)
		else
			obj.setoption('antialias',1)
		end
		-- 回転を計算
		xx = t*obj.rand(-spin,spin,x,y+2000)/100
		yy = t*obj.rand(-spin,spin,x,y+3000)/100
		zz = t*obj.rand(-spin,spin,x,y+4000)/100
		sin_x = math.sin(xx);
		cos_x = math.cos(xx);
		sin_y = math.sin(yy);
		cos_y = math.cos(yy);
		sin_z = math.sin(zz);
		cos_z = math.cos(zz);
		m00 =  cos_y*cos_z
		m01 = -cos_y*sin_z
		m10 =  cos_x*sin_z +sin_x*cos_z*sin_y
		m11 =  cos_x*cos_z -sin_x*sin_z*sin_y
		m20 =  sin_x*sin_z -cos_x*cos_z*sin_y
		m21 =  sin_x*cos_z +cos_x*sin_z*sin_y
		for i=0,3 do
			xx = pu[i]-gx
			yy = pv[i]-gy
			px[i] = m00*xx + m01*yy
			py[i] = m10*xx + m11*yy
			pz[i] = m20*xx + m21*yy
		end
		-- 表示座標を計算
		v = 1/(1+v*v/(l*l)*impact)
		vx = vx*v + obj.rand(-size,size,x,y+4000)*diff
		vy = vy*v + obj.rand(-size,size,x,y+5000)*diff
		vz = vz*v + obj.rand(-size,size,x,y+6000)*diff
		cx = cx + t*vx*sp
		cy = cy + t*vy*sp + t*t*grav
		cz = cz + t*vz*sp
		obj.drawpoly(px[0]+cx,py[0]+cy,pz[0]+cz,px[1]+cx,py[1]+cy,pz[1]+cz,px[2]+cx,py[2]+cy,pz[2]+cz,px[3]+cx,py[3]+cy,pz[3]+cz, pu[0],pv[0],pu[1],pv[1],pu[2],pv[2],pu[3],pv[3])
	end
end
-- 以上、exedit.anm より

@図形
--track0:幅,0,4000,100,1
--track1:高さ,0,4000,100,1
--track2:ライン幅,0,4000,4000,1
--dialog:色/col,local color=0xffffff;図形,local figure=0;

function GetFigureName(figure)
	if figure == 1 then
		return "円"
	elseif figure == 2 then
		return "四角形"
	elseif figure == 3 then
		return "三角形"
	elseif figure == 4 then
		return "五角形"
	elseif figure == 5 then
		return "六角形"
	elseif figure == 6 then
		return "星型"
	end
end

local width = obj.track0
local height = obj.track1
local line = obj.track2

local size = math.max(width,height)
local aspect
if width < height then
	aspect = 1 - width / size
else
	aspect = -1 + height / size
end
obj.load("figure", GetFigureName(figure), color, size, line,  aspect)

@扇型（幅高さ）（設定）
--track0:幅,0,4000,100,1
--track1:高さ,0,4000,100,1
--track2:ライン幅,0,4000,4000,1
--track3:中心角,0,360,270
--dialog:色/col,local color=0xffffff;
local width = obj.track0
local height = obj.track1
local size = math.max(width,height)
if width < height then
	FanAspect = -1 + width / size
else
	FanAspect = 1 - height / size
end
FanL = math.floor(size/2)
FanThickness = obj.track2
FanR = 180 - obj.track3 / 2
FanColor = color

@扇型（幅高さ）（描画）
--track0:中心基準,-100,100,0
local rotate = obj.track0

local figures = require("YMM4/figures")
figures.LoadFan(obj, FanL, FanR, rotate, FanThickness, FanColor)
obj.aspect = FanAspect

@角丸四角形（幅高さ）
--track0:幅,0,4000,100,1
--track1:高さ,0,4000,100,1
--track2:ライン幅,0,4000,4000,1
--track3:角丸,0,4000,4000,1
--dialog:色/col,local color=0xffffff;
local figures = require("YMM4/figures")
local width = obj.track0
local height = obj.track1
local thickness = obj.track2
local round = obj.track3
figures.LoadRoundedRect(obj, width, height, thickness, color, round)

@楔形（幅高さ）
--track0:へこみ,0,100,30
--track1:幅,0,2000,100
--track2:高さ,0,2000,100
--track3:ライン幅,0,2000,2000
--color:0xffffff
local rate = (100 - obj.track0) / 100
local width = obj.track1
local height = obj.track2
local size = math.max(width,height)
local aspect
if width < height then
	aspect = 1 - width / size
else
	aspect = - 1 + height / size
end
local line = obj.track3

local figures = require("YMM4/figures")
figures.LoadWedge(obj, size, rate, line, color)
obj.aspect = aspect

@矢印（幅高さ）（設定）
--track0:幅,0,2000,100,1
--track1:高さ,0,2000,100,1
--track2:長さ,0,8000,100,1
--track3:太さ,0,100,50,1
--dialog:色/col,local color=0xffffff;線の長さ,local type=0;
local width = obj.track0
local height = obj.track1
ArrowSize   = math.max(width,height)
if width < height then
	ArrowAspect = 1 - width / ArrowSize
else
	ArrowAspect = -1 + height / ArrowSize
end
ArrowLength = obj.track2 / 100 * ArrowSize * 2
ArrowStroke = obj.track3 / 100 * ArrowSize / 2
ArrowType = type
ArrowColor = color

@矢印（幅高さ）（描画）
--track0:へこみ,0,30,30,1
local rate   = (100 - obj.track0) / 100

local figures = require("YMM4/figures")
figures.LoadArrow(obj, ArrowSize, rate, ArrowLength, ArrowStroke, ArrowType, ArrowColor)
obj.aspect = ArrowAspect

@中心位置
--track0:モード,-1,8,7,1
--track1:X,-8000,8000,0
--track2:Y,-8000,8000,0
--dialog:位置を保持/chk,local isKeepPosition=0;
local mode = obj.track0
local x = obj.track1
local y = obj.track2


local left = -obj.w / 2 -  obj.cx
local right = obj.w / 2 + obj.cx
local top = -obj.h / 2 - obj.cy
local bottom = obj.h / 2 + obj.cy

if mode == 0 then
	x = left
	y = top
elseif mode == 1 then
	x = 0
	y = top
elseif mode == 2 then
	x = right
	y = top

elseif mode == 3 then
	x = left
	y = 0
elseif mode == 4 then
	x = 0
	y = 0
elseif mode == 5 then
	x = right
	y = 0

elseif mode == 6 then
	x = left
	y = bottom
elseif mode == 7 then
	x = 0
	y = bottom
elseif mode == 8 then
	x = right
	y = bottom
end

obj.cx = obj.cx + x
obj.cy = obj.cy + y
if isKeepPosition == 1 then
	obj.ox = obj.ox + x
	obj.oy = obj.oy + y
end

@影（設定）
--track0:X,-8000,8000,0
--track1:Y,-8000,8000,0
--track2:濃さ,100,100,0
--track3:拡散,0,100,0
shadowX = obj.track0
shadowY = obj.track1
shadowOpacity = obj.track2
shadowBlur = obj.track3

@影（描画）
--track0:回転,-360,360,0
--dialog:色/col,local color=0xffffff;中心で回転/chk,local isRotateAtCenter=0;
local shadowAngle = obj.track0

local originalZoom = obj.getvalue("zoom")/100
local originalWidth = obj.w/originalZoom
local originalHeight = obj.h/originalZoom
obj.setoption("drawtarget", "tempbuffer", originalWidth, originalHeight)
obj.draw()
obj.copybuffer("cache:01", "tmp")

local ox = obj.ox
local oy = obj.oy
local oz = obj.oz
local rx = obj.rx
local ry = obj.ry
local rz = obj.rz
local cx = obj.cx
local cy = obj.cy
local cz = obj.cz

obj.effect("単色化", "強さ", 100, "輝度を保持する", 0, "color", color)
obj.effect("ぼかし", "範囲", shadowBlur)

local zoom = obj.getvalue("zoom")/100
local width = obj.w 
local height = obj.h

local t = math.pi * shadowAngle / 180
local rotatedWidth = math.max(width, math.abs(width * math.cos(t)) + math.abs(height * math.sin(t)))
local rotatedHeight = math.max(height, math.abs(width * math.sin(t)) + math.abs(height * math.cos(t)))
local rotatedCx = 0
local rotatedCy = 0
if isRotateAtCenter==0 then
	rotatedCx = cx * math.cos(t) - cy * math.sin(t) - cx
	rotatedCy = cy * math.cos(t) + cx * math.sin(t) - cy
end
local shadowOffsetX = shadowX - rotatedCx
local shadowOffsetY = shadowY - rotatedCy

obj.setoption("drawtarget", "tempbuffer", rotatedWidth + math.abs(shadowOffsetX), rotatedHeight + math.abs(shadowOffsetY))
obj.draw(shadowOffsetX / 2, shadowOffsetY / 2, 0, 1, shadowOpacity / 100, 0, 0, shadowAngle)

obj.copybuffer("cache:02", "tmp")
obj.copybuffer("tmp", "cache:01")
obj.load("tempbuffer")
obj.copybuffer("tmp", "cache:02")
obj.draw(-shadowOffsetX / 2, -shadowOffsetY / 2)

obj.load("tempbuffer")
obj.ox=ox + shadowOffsetX / 2 * zoom
obj.oy=oy + shadowOffsetY / 2 * zoom
obj.oz=oz
obj.rx=rx
obj.ry=ry
obj.rz=rz
obj.cx=cx
obj.cy=cy
obj.cz=cz